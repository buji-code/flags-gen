// Package generator provides functionality for generating pflags AddFlags methods
// from parsed struct information. It uses Go templates to generate properly
// formatted Go code that creates pflags flag definitions for each struct field.
package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"strings"
	"text/template"

	"github.com/yuvalwz/flags-gen/pkg/types"
)

// Generator handles generation of pflags code from struct information
type Generator struct {
	template *template.Template
}

// New creates a new Generator instance
func New() *Generator {
	tmpl := template.Must(template.New("flags").Parse(flagsTemplate))
	return &Generator{
		template: tmpl,
	}
}

// GenerateFlags generates the AddFlags method for a struct
func (g *Generator) GenerateFlags(structInfo types.StructInfo) (string, error) {
	var buf bytes.Buffer
	
	data := struct {
		StructInfo types.StructInfo
		HasImports bool
	}{
		StructInfo: structInfo,
		HasImports: len(structInfo.Imports) > 0,
	}
	
	if err := g.template.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("failed to execute template: %w", err)
	}
	
	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return "", fmt.Errorf("failed to format generated code: %w", err)
	}
	
	return string(formatted), nil
}

// GenerateFlag generates a single flag declaration
func (g *Generator) GenerateFlag(field types.FieldInfo) (string, error) {
	method, exists := types.GetFlagMethod(field.Type)
	if !exists {
		return "", fmt.Errorf("unsupported type: %s", field.Type)
	}
	
	// Build flag arguments
	args := []string{
		fmt.Sprintf("&o.%s", field.Name),
		fmt.Sprintf(`"%s"`, field.FlagName),
	}
	
	// Add default value
	if field.DefaultValue != nil {
		args = append(args, g.formatDefaultValue(field.DefaultValue, field.Type))
	} else {
		args = append(args, g.getZeroValue(field.Type))
	}
	
	// Add description
	description := field.Description
	if description == "" {
		description = fmt.Sprintf("%s configuration", field.Name)
	}
	args = append(args, fmt.Sprintf(`"%s"`, description))
	
	// Handle short flags for VarP methods
	if field.ShortFlag != "" && types.HasShortFlag(field.Type) {
		method = strings.Replace(method, "Var", "VarP", 1)
		// Insert short flag as third argument
		newArgs := append(args[:2], fmt.Sprintf(`"%s"`, field.ShortFlag))
		args = append(newArgs, args[2:]...)
	}
	
	return fmt.Sprintf("	flags.%s(%s)", method, strings.Join(args, ", ")), nil
}

// formatDefaultValue formats a default value for code generation
func (g *Generator) formatDefaultValue(value interface{}, fieldType string) string {
	switch fieldType {
	case "string":
		return fmt.Sprintf(`"%s"`, value)
	case "[]string":
		if slice, ok := value.([]string); ok {
			quoted := make([]string, len(slice))
			for i, s := range slice {
				quoted[i] = fmt.Sprintf(`"%s"`, s)
			}
			return fmt.Sprintf("[]string{%s}", strings.Join(quoted, ", "))
		}
		return `[]string{}`
	case "time.Duration":
		return fmt.Sprintf("%v", value)
	default:
		return fmt.Sprintf("%v", value)
	}
}

// getZeroValue returns the zero value for a given type
func (g *Generator) getZeroValue(fieldType string) string {
	switch fieldType {
	case "string":
		return `""`
	case "int", "int32", "int64", "uint", "uint32", "uint64", "float32", "float64":
		return "0"
	case "bool":
		return "false"
	case "[]string", "[]int":
		return fmt.Sprintf("%s{}", fieldType)
	case "time.Duration":
		return "0"
	default:
		return `""`
	}
}

// flagsTemplate is the template for generating the AddFlags method
const flagsTemplate = `// Code generated by flags-gen. DO NOT EDIT.

package {{.StructInfo.PackageName}}

{{if .HasImports}}
import (
{{range .StructInfo.Imports}}	"{{.}}"
{{end}}	"github.com/spf13/pflag"
)
{{else}}
import "github.com/spf13/pflag"
{{end}}

// AddFlags adds all the flags from {{.StructInfo.Name}} to the given FlagSet
func (o *{{.StructInfo.Name}}) AddFlags(flags *pflag.FlagSet) {
{{- range .StructInfo.Fields}}
{{- if .FlagMethod}}
	flags.{{.FlagMethod}}(&o.{{.Name}}, "{{.FlagName}}", {{.DefaultValueCode}}, "{{.Description}}")
{{- end}}
{{- end}}
}
`