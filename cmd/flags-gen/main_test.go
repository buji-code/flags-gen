package main

import (
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"
)

func TestCLI_Integration(t *testing.T) {
	// Build the binary first
	buildCmd := exec.Command("go", "build", "-o", "flags-gen-test", ".")
	buildCmd.Dir = "."
	if err := buildCmd.Run(); err != nil {
		t.Fatalf("Failed to build binary: %v", err)
	}
	defer os.Remove("flags-gen-test")

	// Create temporary test directory
	tmpDir, err := os.MkdirTemp("", "flags-gen-integration-test")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(tmpDir)

	// Create test input file
	testFile := filepath.Join(tmpDir, "config.go")
	testContent := `package config

import "time"

// +flags-gen
// AppConfig defines application configuration
type AppConfig struct {
	// Host is the server hostname
	Host string ` + "`json:\"host\" default:\"localhost\"`" + `
	
	// Port is the server port  
	Port int ` + "`json:\"port\" default:\"3000\"`" + `
	
	// Enable debug logging
	Debug bool ` + "`json:\"debug\"`" + `
	
	// Request timeout duration
	Timeout time.Duration ` + "`json:\"timeout\" default:\"30s\"`" + `
	
	// List of allowed origins
	AllowedOrigins []string ` + "`json:\"allowedOrigins\" default:\"http://localhost,https://example.com\"`" + `
}
`

	if err := os.WriteFile(testFile, []byte(testContent), 0644); err != nil {
		t.Fatal(err)
	}

	outputFile := filepath.Join(tmpDir, "config_flags.go")

	// Run the CLI tool
	cmd := exec.Command("./flags-gen-test", "-i", testFile, "-o", outputFile)
	cmd.Dir = "."
	output, err := cmd.CombinedOutput()
	if err != nil {
		t.Fatalf("CLI command failed: %v\nOutput: %s", err, output)
	}

	// Check that output file was created
	if _, err := os.Stat(outputFile); os.IsNotExist(err) {
		t.Fatal("Output file was not created")
	}

	// Read and validate the generated content
	generated, err := os.ReadFile(outputFile)
	if err != nil {
		t.Fatal(err)
	}

	generatedStr := string(generated)

	// Check for expected content
	expectedElements := []string{
		"// Code generated by flags-gen. DO NOT EDIT.",
		"package config",
		`import (`,
		`"github.com/spf13/pflag"`,
		`"time"`,
		"func (o *AppConfig) AddFlags(flags *pflag.FlagSet) {",
		`flags.StringVar(&o.Host, "host", "localhost"`,
		`flags.IntVar(&o.Port, "port", 3000`,
		`flags.BoolVar(&o.Debug, "debug", false`,
		`flags.DurationVar(&o.Timeout, "timeout", 30*time.Second`,
		`flags.StringSliceVar(&o.AllowedOrigins, "allowed-origins"`,
		`[]string{"http://localhost", "https://example.com"}`,
	}

	for _, element := range expectedElements {
		if !strings.Contains(generatedStr, element) {
			t.Errorf("Generated code missing expected element: %s", element)
		}
	}

	// The generated file should be valid Go code - try to parse it
	parseCmd := exec.Command("go", "fmt", outputFile)
	if err := parseCmd.Run(); err != nil {
		t.Errorf("Generated code is not valid Go: %v", err)
		t.Errorf("Generated content:\n%s", generatedStr)
	}
}

func TestCLI_Version(t *testing.T) {
	// Build the binary first
	buildCmd := exec.Command("go", "build", "-o", "flags-gen-test", ".")
	buildCmd.Dir = "."
	if err := buildCmd.Run(); err != nil {
		t.Fatalf("Failed to build binary: %v", err)
	}
	defer os.Remove("flags-gen-test")

	cmd := exec.Command("./flags-gen-test", "version")
	cmd.Dir = "."
	output, err := cmd.CombinedOutput()
	if err != nil {
		t.Fatalf("Version command failed: %v", err)
	}

	if !strings.Contains(string(output), "flags-gen version") {
		t.Errorf("Version output doesn't contain expected text: %s", output)
	}
}

func TestCLI_Help(t *testing.T) {
	// Build the binary first
	buildCmd := exec.Command("go", "build", "-o", "flags-gen-test", ".")
	buildCmd.Dir = "."
	if err := buildCmd.Run(); err != nil {
		t.Fatalf("Failed to build binary: %v", err)
	}
	defer os.Remove("flags-gen-test")

	cmd := exec.Command("./flags-gen-test", "--help")
	cmd.Dir = "."
	output, err := cmd.CombinedOutput()
	if err != nil {
		t.Fatalf("Help command failed: %v", err)
	}

	expectedHelpText := []string{
		"code generation tool that parses Go structs",
		"--input",
		"--output",
		"Input Go file containing structs with +flags-gen annotations",
	}

	outputStr := string(output)
	for _, text := range expectedHelpText {
		if !strings.Contains(outputStr, text) {
			t.Errorf("Help output missing expected text: %s", text)
		}
	}
}

func TestCLI_MissingInput(t *testing.T) {
	// Build the binary first
	buildCmd := exec.Command("go", "build", "-o", "flags-gen-test", ".")
	buildCmd.Dir = "."
	if err := buildCmd.Run(); err != nil {
		t.Fatalf("Failed to build binary: %v", err)
	}
	defer os.Remove("flags-gen-test")

	cmd := exec.Command("./flags-gen-test")
	cmd.Dir = "."
	output, err := cmd.CombinedOutput()
	
	// Should exit with error
	if err == nil {
		t.Error("Expected command to fail when input is missing")
	}

	if !strings.Contains(string(output), "required flag") {
		t.Errorf("Error output should mention required flag: %s", output)
	}
}